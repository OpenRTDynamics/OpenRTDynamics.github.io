


<!-- got from https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css -->
<link rel="stylesheet" href="lib/font-awesome-4.7.0/css/font-awesome.min.css">

<script src="lib/jquery-3.1.0.min.js"></script>
        
<script src="lib/smoothscroll-polyfill/dist/smoothscroll.min.js"></script>





<!-- <link rel="stylesheet" href="lib/highlight/styles/default.css"> -->



<link rel="stylesheet" href="lib/highlight/styles/railscasts.css">
<script src="lib/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<head>
    
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">

    <meta charset="utf-8">
    <title>A framework for Linux-based Real-time control sytems</title>

    <meta name="description" content="OpenRTDynamics (ORTD) is a framework to implement block/signal based control- or signal processing systems and aims to be an open-source alternative to Simulink Coder / LabView / Xcos code generation.">

    <meta name="viewport" content="width=device-width, initial-scale=1">



    <style>
        h1 {
            color: green;
        }

        a {
            color: green;
        }

        body {
/*            background: #ffffff;
            color: #00ff00;
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 20px;
*/

            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 20px;
            font-style: normal;
            font-variant: normal;
            font-weight: 200;
            line-height: 30px;
            color: green;            
        }


        .btn-myself {
            color: #00ff00;
            background-color: #005500;
            border-color: #46b8da;
            border: 2px solid transparent;
            border-radius: 5px;
            /*    font-weight: 400; */
            /*line-height: 2.42857143;*/
            line-height: 1.6;

            font-size: 16px;
        }
        .btn-myself-small {
            color: #00ff00;
            background-color: #005500;
            border-color: #46b8da;
            border: 2px solid transparent;
            border-radius: 5px;
            /*    font-weight: 400; */
            /*line-height: 2.42857143;*/
            line-height: 1.0;

            font-size: 14px;
        }


        .input-myself {
            color: #00ff00;
            background-color: #000000;
            border-color: #46b8da;
            border: 2px solid transparent;
            border-radius: 5px;
            /*    font-weight: 400; */
            line-height: 2.42857143;

            font-size: 16px;
        }

        .MenuTable {
            border-spacing: 0.9em;
        }
       


        h1 {
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 30px;
            font-style: normal;
            font-variant: normal;
            font-weight: 1500;
            line-height: 26px;
            color: green;

            text-align: center;
        }

        h2 {
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 18px;
            font-style: normal;
            /*  font-variant: normal; */
            font-variant: small-caps;
            font-weight: 500;
            line-height: 12px;
            margin-bottom:0.5ex;
            margin-top:0.7ex;
            color: green;
        }

        h3 {
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 14px;
            font-style: normal;
            /*  font-variant: normal; */
            font-variant: small-caps;
            font-weight: 500;
            line-height: 15px;
            color: green;
        }

/*        p {
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 20px;
            font-style: normal;
            font-variant: normal;
            font-weight: 200;
            line-height: 30px;
            color: green;
        }*/

        blockquote {
            font-family: Palatino, 'Palatino Linotype', 'Palatino LT STD', 'Book Antiqua', Georgia, serif;
            font-size: 21px;
            font-style: normal;
            font-variant: normal;
            font-weight: 400;
            line-height: 30px;
            color: green;
        }

        pre {
            font-family: monospace;
            font-size: 11px;
            font-style: normal;
            font-variant: normal;
            font-weight: 400;
            line-height: 15px;
            background: #ffeeff;
            color: green;
        }
        /* Syntax highlighting JSON */

        .code {
            font-size: 16px;
            line-height: 20px;
        }

        .sec {

            background-color: #eeffee;

            margin-bottom:20px;
            margin-top:20px;

            margin-left:20px;
            margin-right:20px;
        }

        .string {
            color: green;
        }

        .number {
            color: darkorange;
        }

        .boolean {
            color: blue;
        }

        .null {
            color: magenta
        }

        ;



        .wrap1 {
            border: 0px solid #c3c3c3;
            display: -webkit-flex;
            /* Safari */
            -webkit-flex-wrap: wrap;
            /* Safari 6.1+ */
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
        }

        .wrap2 {
            border: 0px solid #c3c3c3;
            display: -webkit-flex;
            /* Safari */
            -webkit-flex-wrap: wrap;
            /* Safari 6.1+ */
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            align-items: flex-end;
        }

        .wrap3 {
            border: 0px solid #c3c3c3;
            display: -webkit-flex;
            /* Safari */
            -webkit-flex-wrap: wrap;
            /* Safari 6.1+ */
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .wrap4 {
            border: 0px solid #c3c3c3;
            display: -webkit-flex;
            /* Safari */
            -webkit-flex-wrap: wrap;
            /* Safari 6.1+ */
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
        }

        .wrap5 {
            border: 0px solid #c3c3c3;
            display: -webkit-flex;
            /* Safari */
            -webkit-flex-wrap: wrap;
            /* Safari 6.1+ */
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
        }   

        .sticky {
            position: sticky; 
            top: 0px; z-index: 1;
        }

        .nanobar {
            width: 100%;
            height: 4px;
            z-index: 9999;
            top: 0
        }

        .bar {
            width: 0;
            height: 100%;
            transition: height .3s;
            background: #00ff00;
            color: #00ff00;
            border-radius: 2px;
        }
        /* Div fade in animation */

        .fadein {
            animation: fadein 2s;
        }

        @keyframes fadein {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @-moz-keyframes fadein {
            /* Firefox */
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @-webkit-keyframes fadein {
            /* Safari and Chrome */
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @-o-keyframes fadein {
            /* Opera */
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }



    </style>

</head>






<div class="sticky" style="background: rgba(0, 34, 0, 0.9);">
	<div class="wrap2" style="border: 3px solid transparent;  -webkit-filter: grayscale(70%)">



	 	<div>
	 		<h1>OpenRTDynamics</h1> A framework for Linux-based Real-time control sytems 
	 	</div>

	    <div>
	        <button type="button" class="btn btn-myself" id="OverviewBtn" style="width:170px; height:50px;">Overview</button>
	    </div>
	    <div>
	        <button type="button" class="btn btn-myself" id="InstallationBtn" style="width:170px; height:50px;">Installation</button>
	    </div>
	    <div>
	        <button type="button" class="btn btn-myself" id="ExamplesBtn" style="width:170px; height:50px;">Examples</button>
	    </div>



	    <script>

	    	    $(document).ready(function() {

	    	    	$('#OverviewBtn')[0].onclick = function() {
		                console.log('OverviewBtn');

		                $('#SecOverview')[0].scrollIntoView({ behavior: 'smooth' });
		            };



	    	    	$('#InstallationBtn')[0].onclick = function() {
		                console.log('InstallationBtn');

		                $('#SecInstall')[0].scrollIntoView({ behavior: 'smooth' });
		            };



	    	    	$('#ExamplesBtn')[0].onclick = function() {
		                console.log('ExamplesBtn');

		                $('#SecExamples')[0].scrollIntoView({ behavior: 'smooth' });
		            };





	                        // document.querySelector('#' + ScrollDiv).scroll({ top: YPos, left: 0, behavior: 'smooth' });

	            });

	    </script>




	</div>
</div>
<br>



<div id="ScrollDiv">



<div class="sec">

    <h1 id="SecOverview">Overview</h1>

    <p>OpenRTDynamics (ORTD) is a framework to implement block/signal based control- or signal processing systems and aims to be an open-source alternative to Simulink Coder / LabView / Xcos code generation. This framework is suitable for implementing discrete-time signal processing algorithms, using the same principles like in Scicos/Xcos or Simulink. However, schematics are described by combining special Scilab functions provided by the framework (a typical Scilab-file describing an ORTD-schematic is e.g. <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/oscillator.sce">[]</a>). A comparision to Xcos and Simulink is given in <a href="/Comparison.pdf">Comparison.pdf</a>. The obtained programs are real-time capable.</p>


</div>




<div class="sec">
    <h1 id="SecHow">How it works</h1>


    <div class="wrap2">
        <div class="codebound" style="width: 800px;">
            <pre><code class="Scilab code">
// Superblock: A simple oscillator without damping
function [sim, x,v] = oscillator(sim, u)
    // create a feedback signal
    [sim,x_feedback] = libdyn_new_feedback(sim);

        // use this as a normal signal
        [sim,a] = ld_add(sim, 0, list(u, x_feedback), [1, -1]);
        [sim,v] = ld_ztf(sim, 0, a, 1/(z-1) * T_a ); // Integrator approximation
        [sim,x] = ld_ztf(sim, 0, v, 1/(z-1) * T_a ); // Integrator approximation  
    
        // feedback gain
        [sim,x_gain] = ld_gain(sim, 0, x, 0.6);
    
    // close loop x_gain = x_feedback
    [sim] = libdyn_close_loop(sim, x_gain, x_feedback);
endfunction            
            </code></pre>
        </div>

        <div>
            <ul>
                <li>Each function call ld_* describes the relation between input- and output signals in dependence of potential inner states.</li>
                <li><tt>libdyn_new_feedback</tt> and <tt>libdyn_close_loop</tt> are used to realize feedback-loops. </li>
                <li>By defining the function <tt>oscillator</tt>, a new function for describing I/O relationships is introduced</li>
            </ul>
        </div>

    </div>
</div>



<h1>What you get</h1>

<p>
	ORTD features the ability to implement state machines represented by multiple, switching subsystems (each subsystem corresponds to one state)  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/statemachine/state_machine_ConditionalSwitches.sce">[]</a>  . Subsystems (sub-simulations) can also run in the context of separated threads (with or without synchronisation to another one), e.g. to divide high- and low frequency portions   <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/ThreadedFrequencyDivision/MotionStim.sce">[]</a>  or to run computationally intensive tasks in the background. Because of a remote control interface  <a href="https://github.com/christianausb/OpenRTDynamics/tree/master/Examples/nodejs_webinterface_Level2">[]</a>  and the ability to include Scilab-Code (similar to Matlab S-functions) that could execute e.g. calibration routines  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/scilab/demo/ScilabRTTest/template.sce">[]</a>, ORTD is also ideally suited for laboratory automation.&#160;   Hereby, the ability to online-replace sub-schematics (sub-simulations) with replacements  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/nested/demo/online_replacement/main_experiment.sce">[]</a> <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/nested/demo/online_replacement/create_replacement.sce">[]</a>  removes the effort of restarting the main real-time program when new algorithms are designed. An example for automating experiments using these concepts:  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/Automation/demo/Example2/RTmain.sce">[]</a>.  The reliability of ORTD has been proven in a number of large experimental set-ups in medical engineering.
</p>


<p>
	Because the real-time interpreter is implemented in a shared library, ORTD can also be easily integrated into other simulation frameworks e.g. Scicos or used within other software. The LGPL-license also allows commercial usage.
</p>

<p>
	Slides that give a short introduction are available:&#160;<a href="/ortd_slides.pdf">ortd_slides.pdf</a>&#160;(updated 02.6.2014). For technical details please refer to the&#160;<a href="https://github.com/OpenRTDynamics/ORTD/blob/master/README.md">README</a>. It also includes intructions on how to install ORTD on embedded ARM-systems, like the beaglebone. A tutorial and plenty of examples for each feature of ORTD are included in the package and finally, documentation for each individual block is available through the Scilab-Help.
</p>

<p>
	<strong>Please Note: </strong>OpenRTDynamics does not depend on any part of Scicos/Xcos. ORTD does not use code-generation, but instead, algorithms for time-deterministic interpretation of simulations instead. The Scilab programming language is used for describing the schematics. When you run the Scilab-file a compilation procedure is performed resulting in a binary-like representation of your algorithm. This code can be transferred and executed by the ORTD-interpreter on the target device.

    <!-- 

    . During runtime, no              more than standard C/C++ libraries are required, therefore              ORTD is very uncomplicated to install and maintain, even on              other platforms. Difficult and cryptic instructions for               the installation of this framework were intentionally avoided. -->
</p>











<p><tt>Tags: Realtime control implementation, Laboratory automation, Linux RT-Preempt, Signal-based simulation, Scilab, Embeddable C-Code libray, No code generation required</tt></p>







<div class="sec">

<h1 id="SecInstall">Installation</h1>



<h2>Installation of the interpreter</h2>

    <p>On any target device (e.g. any Linux-based ARM-single board computer, Ubuntu, MacOS): 
        Clone the repository at <a href="https://github.com/OpenRTDynamics/ORTD"> GitHub </a> into your favorite directory:</p>

    <p>
    <tt>git clone https://github.com/OpenRTDynamics/ORTD.git<br>
    cd ORTD
    </tt>
    </p>

    <p>If you are compiling for Mac, you should configure the proper target: </p>

    <tt>echo MACOSX > target.conf</tt>

    <p>To compile and install issue</p>

    <p>
    <tt>make config</tt> <br>
    <tt>make</tt> <br>
    <tt>make install</tt> <br>
    </p>


    <p>Now, you can try to run the interpreter</p>

    <p>
    <tt>ortdrun</tt> <br>
    </p>

    <p>
    <strong>Please note:</strong> This is only the basic installation. Depending on the presence of certain libraries, the functionality of the interpreter might be limited.
    </p>


</div>




<h1 id="">Feature Overview</h1>


<p>Several modules are available to extend the basic functions:</p>

<p>
<ul>
    <li>Online replacement of sub-controllers; Yes, can can exchange wires and blocks during the controller is running (modules/nested)</li>
    <li>State machines (modules/nested)</li>
    <li>Simulations running in threads (modules/nested)</li>
    <li>Mathematical formula parsing (modules/muparser)</li>
    <li>Vector handling blocks (modules/basic_ldblocks)</li>
    <li>Calling Scilab from the simulation (modules/scilab)</li>
    <li>Remote control interface (modules/rt_server)</li>
    <li>Starting external processes (modules/ext_process)</li>
    <li>Timer for simulations running in threads (pending) (modules/synchronisation)</li>
<!--     <li>Scicos to ORTD block wrapper (modules/scicos_blocks)  <a href="https://github.com/christianausb/OpenRTDynamics/tree/master/include_hart_V2">[A template for easily including Xcos-blocks]</a></li> -->
    <li>A framework for sending/receiving UDP-packets (modules/udp_communication)</li>
</ul>
</p>




<h1 id="">Basic concepts</h1>

ORTD supports basic features like (realtime) threads, for-loops, state-machines ...


<div class="sec">
    <h1 id="SecHow">Threads</h1>


    <div class="wrap2">
        <div class="codebound" style="width: 800px;">
            <pre><code class="Scilab code">
// The main real-time thread
function [sim, outlist, userdata] = Thread_MainRT(sim, inlist, userdata)
  // This will run in a thread
  [sim, Tpause] = ld_const(sim, 0, 1/27);  // The sampling time that is constant at 27 Hz in this example
  [sim, out] = ld_ClockSync(sim, 0, in=Tpause); // synchronise this simulation

  // print the time interval
  [sim] = ld_printf(sim, 0, Tpause, "Time interval [s]", 1);

  // save the absolute time into a file
  [sim, time] = ld_clock(sim, 0);
  [sim] = ld_savefile(sim, 0, fname="AbsoluteTime.dat", source=time, vlen=1);

  //
  // Add you own control system here
  //

  outlist = list();
endfunction


ThreadPrioStruct.prio1=ORTD.ORTD_RT_NORMALTASK; // or  ORTD.ORTD_RT_REALTIMETASK
ThreadPrioStruct.prio2=0; // for ORTD.ORTD_RT_REALTIMETASK: 1-99 as described in   man sched_setscheduler
                          // for ORTD.ORTD_RT_NORMALTASK this is the nice-value (higher value means less priority)
ThreadPrioStruct.cpu = -1; // The CPU on which the thread will run; -1 dynamically assigns to a CPU, 
                           // counting of the CPUs starts at 0
                           


[sim, StartThread] = ld_initimpuls(sim, 0); // triggers your computation only once
[sim, outlist, computation_finished] = ld_async_simulation(sim, 0, ...
                      inlist=list(), ...
                      insizes=[], outsizes=[], ...
                      intypes=[], outtypes=[], ...
                      nested_fn = Thread_MainRT, ...
                      TriggerSignal=StartThread, name="MainRealtimeThread", ...
                      ThreadPrioStruct, userdata=list() );

       
            </code></pre>
        </div>

        <div>
            <ul>
                <li>Unlimited number of threads</li>
                <li>Each thread has its own loop-timing as enforced by <tt>ld_ClockSync</tt> </li>
                <li>Irregular timing possible</li>
              
            </ul>
        </div>

    </div>
</div>



<div class="sec">
    <h1 id="SecHow">For-loops</h1>


    <div class="wrap3">
        <div class="codebound" style="width: 800px;">
            <pre><code class="Scilab code">
function [sim, outlist, userdata] = ForLoopFn(sim, inlist, LoopCounter, userdata)
  // input data
  in1 = inlist(1);
  in2 = inlist(2);

  // sample data for the output
  [sim, outdata1] = ld_constvec(sim, 0, vec=[1200]);

  [sim, LoopCounter] = ld_Int32ToFloat(sim, 0, LoopCounter);
  [sim] = ld_printf(sim, 0, LoopCounter, "Loop count active: ", 1);

  // the user defined output signals of this nested simulation
  outlist = list(outdata1);
endfunction
       
[sim, outlist, userdata] = ld_ForLoopNest(sim, 0, ...
inlist=list(data1, data2), ..
insizes=[1,2], outsizes=[1], ... 
intypes=[ORTD.DATATYPE_FLOAT,ORTD.DATATYPE_FLOAT  ], outtypes=[ORTD.DATATYPE_FLOAT], ...
ForLoop_fn=ForLoopFn, SimnestName="ForLoopTest", NitSignal=CountTo, list("UserdataTest")  );
            </code></pre>
        </div>

        <div>
            <ul>
                <li>Nested simultion is executed for each turn of the for-loop.</li>
              
              
            </ul>
        </div>

    </div>
</div>






<div class="sec">
    <h1 id="SecHow">Documentation</h1>


    <a href="scilab_en_US_help/index.html"> HTML-Documentation pages </a>

</div>




<h1 id="SecExamples">Examples</h1>

<p>
A plenty amount of examples demonstrating the use of various functions is given in the  
<a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/">example-folder</a>.

Furthermore, examples specific to the individual modules (e.g. how to interface I2C-hardware) are generally found in the demo-subfolder of each module. 
<a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/">The folder of all modules</a>.



A <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/TemplateModule_V2/">template</a> for the development of modules/plugins in C++ might be further useful to integrate custom-hardware.

</p>





<h2>Data Visualisation / User Control</h2>

<p>
	A new open-source, plugin-based software  <a href="https://github.com/TUB-Control/PaPI/tree/development">PaPi</a> for live-visualisation and user interaction in conjunction with real-time control systems  is currently being developed at Technische Universität Berlin. It is the successor of the software qrtailab that could only be used in combination with RTAI. There is full support for ORTD and ongoing support for Simulink. It allows you to easily create Graphical User Interfaces to your real-time programs. All GUI-logic along with possible calibration routines can be implemented in the real-time target using into ORTD embedded Scilab. PaPI is used to connect to such RT-programs via a network connection.  <a href="https://github.com/TUB-Control/PaPI/tree/development/data_sources/ORTD/DataSourceChangingAutoConfigExample">[GUI Example]</a>.  <a href="https://github.com/TUB-Control/PaPI/tree/development/data_sources/ORTD/DataSourceExample">[static GUI]</a>.  


</p>

<center>
<iframe width="580" height="435" src="https://www.youtube.com/embed/9B2BISXaPdo" frameborder="0" allowfullscreen=""></iframe>
</center>






<!-- 
<p>
	<img src="/bigace/public/index.php?cmd=image&amp;id=4_len" alt="" width="604" /> 
</p>
 -->



<p>As an alternative, it is made easy to implement web-based user interfaces.</p>

<center>
<iframe width="580" height="435" src="https://www.youtube.com/embed/Mln_JxfzLD0" frameborder="0" allowfullscreen=""></iframe>
</center>

<p>
In this example, an ORTD simulation (real-time part) is communicating to a node.js script by UDP-packets. The node.js part provides a web-interface and streams the information from the real-time part to the web-interface. Additionally, parameter changes are forwarded from the web-interface to the real-time part.  The source-code is available from  <a href="https://github.com/christianausb/OpenRTDynamics/tree/master/Examples/nodejs_webinterface">[]</a>.  
</p>






<h1>Future Directions</h1>

<p>
In addition to the existing state machines, logic constructs like Select/Case (done; in svn)  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/ExecutionControl/SelectCase.sce">[]</a>  , for-loops  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/examples/ExecutionControl/ForLoop.sce">[]</a> (also done; in svn)  , do-until-loops will be added. These apply to nested simulations that are e.g. conditionally executed or for multiple times in a loop. For visualisation and user control purposes, a strong collaboration with PaPi is ongoing to allow automatically generated user interfaces  (with minimal effort for the user) that allow e.g. interaction with automated experiments.
</p>



<!-- 
<h2>Linux rt-preempt Benchmarks</h2>

<p>
A benchmark to evaluate the real-time capabilities is available:  <a href="https://github.com/OpenRTDynamics/ORTD/blob/master/modules/synchronisation/demo/TestRealTime.sce">Cycletest</a>
</p>

<p>
You could also consider this as an example on how to start multiple threads with different priorities and CPU assignments.  Here are some test results, where the time durations between neighbouring samples is plotted for a thread that runns with real-time scheduling and for one that runns without any special priorities. The desired sample time is 0.002s which corresponds to a sampling frequency of 500Hz.
</p>

<p>
Test results for Ubuntu 12.04, Intel(R) Core(TM)2 Duo CPU, Linux 3.2 (no special patches) <a href="/RTTest/Ubuntu_12.04_Linux_3.2/Ubuntu_12.04_Linux_3.2.pdf">(PDF)</a>. Further results (including tests for Mac OS X) are given at <a href="https://github.com/christianausb/OpenRTDynamics/tree/master/RealTimeBenchmarkResults">[]</a>. 
</p> -->


<h1>Acknowledgement / References</h1>


<!-- 
is actively developed and heavily used for implementing feedback controllers in biomedical engineering and research at Control Systems Group,  <a href="http://www.control.tu-berlin.de">www.control.tu-berlin.</a>
 -->






<p>
	Huge portions have been funded by the European Commision (2010-2013) in the 7th framework Program within the project <a href="http://www.mundus-project.eu/">MUNDUS</a>. During this project, ORTD has been used to develop a prototype for a next generation neuro-prosthetic system.  

</p>

<p>
    Development was, further, funded by the German Federal Ministry of Education and Research (BMBF) within the project BeMobil (FKZ 16SV7069K) and by European project RETRAINER (Horizon 2020, Research and Innovation Programme, grant agreement No 644721). 
</p>






<!-- 

<br />
<a href="http://scholar.google.de/scholar?hl=de&amp;q=openRTDynamics&amp;btnG=&amp;lr=">Scientific publications on experiments that were implemented using this framework</a> <br />
<br />
<p>&#160;</p>
<h3 style="color: red; ">Team</h3>
<br />
Christian Klauer, klauer@control.tu-berlin.de, <a href="http://www.control.tu-berlin.de/User:Christian_Klauer">Control-Systems-Group TU-Berlin</a>; framework design, implementation, coordination  <br />
<br />
Arne Passon, <a href="http://http://www.control.tu-berlin.de/User:Arne_Passon">Control-Systems-Group TU-Berlin</a>; API design, implementation  <br />
<br />
Stefan Ruppin, Control-Systems-Group TU-Berlin; PaPi integration  <br />
<br />
Markus Valtin, Control-Systems-Group TU-Berlin; contributions  <br />
<br />
Maximilian Irmer; contributions  <br />
<br />
<p>If you need help in installing or development using ORTD, please don't hesitate to contact one of the authors. Let us know for what kind of project you are interested in to use ORTD; probably we may advise in design questions.</p>
<br />
<br />
<h3 style="color: red; ">Motivation for another real-time framework</h3>
<br />
Since I'm working in the field of biomedical control engineering, my expectations on  the reliability &amp; flexibility of the software controlling something that is acting on  the human body are very high. <br />
<br />
When doing experiments in clinical environments, only limited time is available. Faults  in the operation are critical up to some high extend and technical inadequacies like  instable software that requires several attempts to fully run can simply not be accepted. It shall be possible to re-calibrate and make individual adaptations to the implementation in the shortest time possible. Therefore, instead of code generation, this framework  uses an interpreter (the Scilab description is assembled faster than generating and  compiling C-Code). Additionally, new sub-implementations can be designed and loaded  on-line while e.g. the data acquisition devices stay up and running.<br />
<br />
Also I don't like complicated installation procedures where one has to edit files, adapt directory paths and install numerous other libraries from their sources by hand. ORTD compiles and installs itself automatically from its source files on the individual target system. If there is a library installed that could enable additional functionality  for ORTD, it is used. If not installed, ORTD doesn't complain.<br />
<br />
If you find a bug in the software or things that you just do not find so nice, it would be very cool if give me a short notice/comment by Email. Even complaints like  "I have to type so much commands when doing ..." are REALLY welcome. Every time the user  of this framework is subjected to an higher programing effort than theoretically necessary,  something could be improved! Thus let me know. ORTD is supposed be as smart and relaxed  as possible.<br />
<br />
<br />
</span></meta>
</p>
 -->



</div>